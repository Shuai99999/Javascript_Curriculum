{"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA4FI,GAEJ,wBAAwB;AACxB,kEAAkE;AAClE,qBAAqB;AACrB,sBAAsB;AACtB,qBAAqB;AACrB,iEAAiE;AAEjE,MAAM,QAAQ;IACZ,MAAM;QACJ;YAAE,SAAS;YAAS,UAAU;QAAE;QAChC;YAAE,SAAS;YAAS,UAAU;QAAE;KACjC;IACD,MAAM;QAAE,QAAQ;IAAK;AACvB;AACA,MAAM,aAAa,OAAO,MAAM,CAAC,CAAC,GAAG;AACrC,mCAAmC;AACnC,QAAQ,GAAG,CAAC;AAEZ,MAAM,iBAAiB,UAAU;AACjC,MAAM,IAAI,CAAC,MAAM,GAAG;AACpB,8BAA8B;AAC9B,QAAQ,GAAG,CAAC,iBAEZ,uCAAuC;CACvC,0BAA0B","sources":["script.js"],"sourcesContent":["/*\r\n\r\n// Importing module\r\n// import { addToCart, totalPrice as price, tq } from './shoppingCart.js';\r\n\r\n// addToCart('bread', 5);\r\n// console.log(price, tq);\r\n\r\nconsole.log('Importing module');\r\n\r\n// import * as ShoppingCart from './shoppingCart.js';\r\n// ShoppingCart.addToCart('bread', 5);\r\n// console.log(ShoppingCart.totalPrice);\r\n\r\n// 这个add的名字是随便起的，它代表shoppingCart.js中的default变量\r\nimport add, { cart } from './shoppingCart.js';\r\n\r\nadd('pizza', 2);\r\nadd('bread', 5);\r\nadd('apple', 4);\r\n\r\nconsole.log(cart);\r\n\r\n// await新特性，可以工作在async函数之外，但必须得在module下使用\r\n// const res = await fetch('https://jsonplaceholder.typicode.com/posts');\r\n// const data = await res.json();\r\n// console.log(data);\r\n// console.log('Something');\r\n\r\nconst getLastPost = async function () {\r\n  const res = await fetch('https://jsonplaceholder.typicode.com/posts');\r\n  const data = await res.json();\r\n  \r\n  return { title: data.at(-1), text: data.at(-1).doby };\r\n};\r\n\r\nconst lastPost = getLastPost();\r\nconsole.log(lastPost);\r\n\r\n// Not very clean\r\n// lastPost.then(last => console.log(last));\r\n\r\n// 改写为下面的await写法\r\n// 与上面的lastPost相比，lastPost2可以等待getLastPost执行完并得到其json结果\r\n// 这种写法，被导入的模块是顶级等待，scirpt.js会等待shoppingCart.js全加载完，再执行scirpt.js它自己\r\nconst lastPost2 = await getLastPost();\r\nconsole.log(lastPost2);\r\n\r\n// 这里先写个IIFE函数，在调用它，利用的是closure原理，具体参考前面的课程，相当于是利用函数的封装功能模拟了import一个module进来\r\nconst ShoppingCart2 = (function () {\r\n  const cart = [];\r\n  const shippingCost = 237;\r\n  const totalPrice = 237;\r\n  const totalQuantity = 23;\r\n  \r\n  const addToCart = function (product, quantity) {\r\n    cart.push({ product, quantity });\r\n    console.log(\r\n      `${quantity} ${product} added to cart (shipping cost is ${shippingCost})`\r\n    );\r\n  };\r\n  \r\n  const orderStock = function (product, quantity) {\r\n    cart.push({ product, quantity });\r\n    console.log(`${quantity} ${product} ordered from supplier`);\r\n  };\r\n  \r\n  return {\r\n    addToCart,\r\n    cart,\r\n    totalPrice,\r\n    totalQuantity,\r\n  };\r\n})();\r\n\r\nShoppingCart2.addToCart('apple', 4);\r\nShoppingCart2.addToCart('pizza', 2);\r\nconsole.log(ShoppingCart2);\r\nconsole.log(ShoppingCart2.shippingCost);\r\n\r\n// CommonJS Modules\r\n// 是一种比较旧的module写法，主要用于NodeJS中，了解即可\r\n// Export 主要是export.关键字\r\n// export.addToCart = function (product, quantity) {\r\n  //   cart.push({ product, quantity });\r\n  //   console.log(\r\n    //     `${quantity} ${product} added to cart (shipping cost is ${shippingCost})`\r\n    //   );\r\n    // };\r\n    \r\n    // Import\r\n    // const { addToCart } = require('./shoppingCart.js');\r\n    */\r\n\r\n// npm 是一种方便的js插件安装资源管理器\r\n// 如果不小心遗失已安装的部分文件或目录，由于jason文件还在，可以通过npm i直接通过jason文件把遗失的东西自动安装回来\r\n// 这样安装leaflet和lodash\r\n// npm install leaflet\r\n// npm install lodash\r\n// import cloneDeep from './node_modules/lodash-es/cloneDeep.js';\r\n\r\nconst state = {\r\n  cart: [\r\n    { product: 'bread', quantity: 5 },\r\n    { product: 'pizza', quantity: 5 },\r\n  ],\r\n  user: { Loggin: true },\r\n};\r\nconst stateClone = Object.assign({}, state);\r\n// stateClone在栈内存中，即使在打印后定义它也是false\r\nconsole.log(stateClone);\r\n\r\nconst stateDeepClone = cloneDeep(state);\r\nstate.user.Loggin = false;\r\n// 深度克隆，即使是在定义后打印，也是原来的true的样子\r\nconsole.log(stateDeepClone);\r\n\r\n// Bundling with parcel and NPM scripts\r\n// npm i parcel --save-dev\r\n"],"names":[],"version":3,"file":"index.672d4772.js.map","sourceRoot":"/__parcel_source_root/"}